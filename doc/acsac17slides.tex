\documentclass{beamer}
\usepackage{algorithm2e}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{amsthm}
\newtheorem{conj}{Conjecture}[section]
\let\footnotesize\tiny

%\title{Investigation: Fuzzing (Hybrid) Program Slices}
%\author{Andrew R. Reiter\\
%\tiny CA Veracode}
%\date{\today}

\begin{document}

%\frame{\titlepage}

%\section{Investigating }
\frame
{
	\frametitle{Investigating Fuzzing (Hybrid) Program Slices}
	\tiny
	
	\fboxsep=0pt
		\noindent\hbox{%
	\begin{minipage}[t]{0.48\linewidth}
	High-level version of algorithm:
	\begin{algorithm}[H]
		\SetAlgoLined
		\KwData{Program P, sample input I}
		\KwResult{$C = $\{$c \in inputs(P) \vert exec(P,c) \rightarrow$ crash\}}
		$A \leftarrow Analysis(P, I)$\;
		$S_d \leftarrow Slice(P, A, $ depth $d)$\;
		$\{c'_{d,i}\}_i \leftarrow Fuzz(S_d, I)$\;
		\For{$c' \in \{c'_{d,i}\}_i$}{
			$c \leftarrow MapCrash(P, S_d, c')$\;
			$C.append(c)$\;
		}
	\end{algorithm}\end{minipage}}%
\hfill%
\fbox{
	\begin{minipage}[t]{0.48\linewidth}

	Given the algorithm to the left, the conjecture investigated is
	
	\begin{conj} There exists a Slice() algorithm such that the MapCrash() algorithm either
	\begin{itemize}
	\item maps samples crashing $S_d$ to samples crashing $P$ with no modification
	\item maps samples crashing $S_d$ to samples crashing $P$ with minimal difficulty or human interaction (heh).
	\end{itemize}
	\end{conj}

	\end{minipage}
}
	

	Many possibilities for Analysis, Slice, Fuzz, and MapCrash functions. The current, very \textbf{naive} approach is implemented:
	\begin{itemize}
	\item For \emph{Analysis()}: execution flow from a given desirable input (i.e. execution trace log)
	\item For \emph{Slice()}: attempt to remove the non-exec'd basic blocks of functions reached, unless they are the destination
	block for a compare-branch that we wish to keep (such as if (read() < 0) ...).
	\item For \emph{MapCrash()}: fuzz original $P$ with input samples that are crashes from fuzzing $S_d$. 
	with the idea being that under some measurable fuzzing space $\left\vert d(c) - d(c') \right\vert \leq$ something reasonable.
	\end{itemize}
	and using afl-fuzz. 
	
	Find this code and horseplay: \url{https://github.com/roachspray/acsac17wip}
}


\frame
{
	\frametitle{Minimal set of results}
	\tiny

	
	\begin{center}
	\begin{tabular}{|l | l | l  | l | l | l| l |}
	\hline
	Program          & Input      & Slice Depth  & P 5h fuzz &  S\_d 1h fuzz & Mapped 4h fuzz & Size Change\\ \hline
	cracklib-2.9.2-5 & smalldict   & 1 & 0 & 3 & 0 & \\ \hline
	                 &             & 2 & 0 & 0 & 0 & \\ \hline
	                 &             & 3 & 0 & 0 & 0 & \\ \hline
	exifprobe current & tryone.jpg & 3 & ? & 27 & 37 & \\ \hline
	                  &            & 4 & ? & 30 & 50 & \\ \hline
	                  &            & 5 & ? & 27 & 13 & \\ \hline
	                  &            & 6 & ? & 28 & 30 & \\ \hline
	tcpdump current   & ntp.pcap   & 6 & 0 & 0 & 0  & \\ \hline
	                  & ntp.pcap   & 7 & 0 & 0 & 0  & \\ \hline
	                  & ntp.pcap   & 8 & 0 & 0 & 0  & \\ \hline
	                  & ntp.pcap   & 9 & 0 & 0 & 0  & \\ \hline
                      & hcrt.pcap  & 7 & 0 & 1 & 0  & \\ \hline
                      &            & 8 & 0 & 6 & 0  & \\ \hline
                      &            & 9 & 0 & 0 & 0  & \\ \hline
                      &            & 10 & 0 & 0 & 0 & \\ \hline
                      & arp.pcap   & 3 & 0 & 0 & 0 & \\ \hline
                      &    & 4 & 0 & 0 & 0 & \\ \hline                      
                      &    & 5 & 0 & 0 & 0 & \\ \hline
                      &    & 6 & 0 & 0 & 0 & \\ \hline
                      &    & 7 & 0 & 0 & 0 & \\ \hline
                      &    & 8 & 0 & 0 & 0 & \\ \hline                                                                  
	\end{tabular}
	\end{center}

	
	So, there are some concerns:
	\begin{itemize}
	\item How to choose timebox times? Are they even reasonable? These are timeboxed and not-averaged timeboxed; 
	\item How to measure success or failure? Clearly not finding bugs could imply failure.. Leads to the question of whether
	needs to be some public data set of fuzzing methods, hardware, and times until certain specific bugs were found. Sadly might lead
	to tuning toward those, but that's not the goal.
	\item It seems slicing could do better reduction in code size, fix.
	\end{itemize}
}

\frame
{
	\frametitle{Next Steps}
	\tiny
	\begin{itemize}
	\item Improve \emph{Analysis} step. Initially included static value flow analysis, but the code was not working. Investigate clang analyze or hand developed. Also include the use of either manticore\footnote{\url{https://github.com/trailofbits/manticore}} or libdft\footnote{\url{https://www.cs.columbia.edu/~vpk/research/libdft/}}.
	\item Improve \emph{Slice} step by better dead code removal
	\item Improve \emph{Slice} step to use data flow information in block / function removal selection
	\item Investigate  possible \emph{MapCrash} methods:
	\begin{itemize}
	\tiny
	\item Cascade AFL: $(C_d \leftarrow Fuzz(S_d, In)) \rightarrow (C_{d-1} \leftarrow Fuzz(S_{d-1}, C_d)) \rightarrow \ldots \rightarrow (C_0 \leftarrow Fuzz(P, C_1))$ \\
	and reduce times for each level.
	
	\item Selective AFL instrumentation based on slicing information. See \footnote{https://github.com/roachspray/acsac17wip/blob/master/patches/afl-2.51b-optionally-instrument-based-on-trace.patch}
	\item Use manticore to guide program until input causes divergence from slice crash path with input. At this point, form CSP, attempt
	to solve CSP using z3. Adjust input, continue guiding toward crash state, if possible. 
	\end{itemize}
	\end{itemize}
	As you can tell, this work is still in it's infancy and there are many paths to investigate. Trying to determine best routes and
	choices to keep the science legit is an important piece (i.e. some understanding of a ground truth). But, many other areas to play.
	I would greatly appreciate anyone interested to combine forces, or outright take some ideas and go forth.
	
}
\end{document}
